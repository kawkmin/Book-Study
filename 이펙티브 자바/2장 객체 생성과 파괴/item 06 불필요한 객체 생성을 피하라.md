# item 06 불필요한 객체 생성을 피하라

# 요약

객체를 매번 생성하려고 하지 말고 가독성 등에 영향을 미치지 않는 한에서 재사용을 고려해보자.

또한 String과 오토박싱 등 잘 모르고 사용하면 독이될 수 있다

# 주요 내용

객체를 생성한다. = RAM을 차지한다. = 성능이 떨어진다. (비용 증가)

불필요한 객체 생성? 무엇을 말하는지 모호하다. 자바로 개발하면서 흔히 있는 사례로 소개.

### 1. String s = new String(”asdf”); 의 문제점들

이를 이해하려면 String에 대한 이해가 필요함.

1. `“asdf”` 자체가 또 인스턴스를 생성하는 거고, 실행할 때 마다, 매번 인스턴스를 생성하게됨
2. `String s = “asdf”` 는 JVM이 **Java String Pool** 이라는 String 문자열만 따로 메모리에 저장함. 따라서 다음에 “asdf”를 사용할 때, 재사용함으로써(캐쉬) 성능을 높임.

### 2. 정적 팩터리 메서드(아이템 1)를 사용하면, 불필요한 객체 생성 줄일 수 있음

예를 new Boolean()을 사용하지 말고, Boolean.valueOf()를 사용하면 미리 만들어놓은 인스턴스를 사용하기 때문에 비용을 아낄 수 있음

### 3. 오토박싱을 사용할 때 주의점

오토박싱은 아주 편리하지만 만능은 아니다.

```java
private static long sum(){
	Long sum = 0L;
	for (long i =0; i<= Intger.MAX_VALUE; i++){
		sum += i; // long 타입이 Long 타입으로 오토박싱이됨
	}
	return sum;
}
```

Stack 영역으로 저장되는 기본 타입(원시 타입)이 래퍼 클래스(객체)로 변하면서 수많은 인스턴스를 생성하게 되는 것이다.

따라서 불필요한 박싱을 피하고 기본 타입을 쓰는게 더 좋음.

### +) 객체 생성이 비싸면 캐싱을 통해 객체 생성을 방지할 수 있다.

Pattern을 예로 들자면

```java
// 캐싱 사용 X
static boolean isRomanNumeral(String str) {
    return str.matches("^(?=.)M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$"); 
}

// 캐싱 사용 O
public class RomanNumber {
    private static final Pattern ROMAN = Pattern.compile("^(?=.)M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");

    static boolean isRomanNumeral(String str) {
        return ROMAN.matcher(str).matches();
	}
}
```

밑에 코드처럼 생성이 비싼 Pattern 객체를 미리 선언 후, 추후 재사용하면 인스턴스가 재생성될 일이 없다.

하지만 만약 한번만 사용하면 쓸데없긴 하다. 리팩토링으로 고려해보는 것도 좋을 것 같다.

- 지연 초기화가 있는데 코드를 너무 복잡하게 만들어서 비추.

여담으로 요즘 JVM의 GC는 상당히 최적화가 잘 되어서 위처럼 심각하지 않으면 성능이 잘 나오니 코드의 가독성, 복잡성등을 해치면서까지 할 필요는 없다! (오히려 가독성을 위한 객체 생성은 권장)

이런 이유로 불필요한 객체 생성을 피해야하지만, 방어적 복사가 필요한 상황에선 오히려 재사용 하지말고 반복 생성하는게 훨씬 안전해진다. (아이템 50)

이건 성능에만 조금 영향을 갈 수 있지만, 방어적 복사에 실패하면 버그와 보안 구멍 등 아주 치명적으로 작용할 수 있다. 상황에 맞게 설계하자!

# 질문 및 추가